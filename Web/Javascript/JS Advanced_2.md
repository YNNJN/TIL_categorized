### Summary

- 함수 선언문 vs 함수 표현식
  - 자스에서는 모든 선언이 호이스팅 됨
  - 변수 호이스팅 막기 위해 let, const의 키워드가 있었음
  - 가장 큰 차이점은 호이스팅을 적용했을 때 어떻게 작동하는지가 차이
    - 함수 선언문 - 선언, 초기화, 할당이 모두 이루어져 실행 가능
    - 함수 표현식 - 변수 호이스팅이 발생하여, undefined. 즉 실행 불가
- 함수를 인자로 넘겨줄 수 있고 반환도 가능 - 일급객체 개념
- 비단 함수만이 아니라 원시 타입도 그렇게 쓰고있는 것
- 클로저~파이썬, LEGB, 키워드 E(inner function 윗부분)의 핵심











- 콜백 함수 - 메소드 실행 시 자동으로 호출되는 함수
- Closure - 자신의 유효 범위 밖에 있는 변수에 접근할 수 있는 함수. JavaScript 함수의 특징











### 생성자를 이용한 함수 정의

- 자바스크립트 함수 = 객체, 데이터 -> 생성자를 이용하여 함수 정의 가능

- var 변수 = new Function("전달인자1", "전달인자2", "전달인자3", ... , "함수코드")

- 생성자를 사용해 정의한 함수

  - 1. 필요한 기능을 동적으로 생성하고
    2. 이름 없는 함수를 생성함 (익명함수)
       - 생성되어 변수(함수의 이름 역할)에 할당됨
  - 실행은 var value = tempConvert(100);
    - 즉 함수 이름 = 함수 객체를 가리키는 참조

  - 함수를 동적으로 생성함
    - 함수 호출 -> 함수 생성 -> 함수 처리 -> 함수 소멸
  - 반복문에서의 사용을 피해야
    - 매번 함수를 동적으로 생성할테니

- 리터럴 형태로 정의한 함수

  - 생성자 없이 함수를 생성하여 변수에 할당 가능
  - 함수가 딱 한 번만 사용된다면 매우 효율적. 정의 후 바로 호출되어 실행하거나 다른 함수의 전달 인자로 전달될 수 있으니
  - 구문 아닌 표현식임 -> 함수 리터럴에서 정의된 함수를 사용하려면 함수 리터럴 정의 후에 사용해야

  ```javascript
  var 변수 = function(전달인자들){
    함수 구문들;
  };
  ```

- 함수 객체도 메소드와 프로퍼티 적용 가능













### Array helper methods

- MDN 문서의 정의는 콜백함수로 표현 - **콜백함수**란 메소드 실행 시 자동으로 호출되는 함수
  - 함수의 형태가 호출이 아닌, **선언**을 하고있음

- filter 메소드 - 주어진 함수를 배열의 요소 각각에 대해 실행하여 반환 값이 true인 요소를 모아 배열을 반환
  - 전달인자는 element,  index, array
- forEach 메소드 - 주어진 함수를 배열의 요소 각각에 대해 실행
  - ele 하나하나를 콜백함수에 전달하여 처리함
- every 메소드 - 주어진 함수의 모든 요소가 true인 경우 ture(불리언 값을 반환)
- some 메소드 - 주어진 함수가 하나라도 true인 경우 ture(불리언 값을 반환함)
- map 메소드 - 주어진 함수를 배열의 요소 각각에 대해 실행한 결과를 모아 배열을 반환
- 이외에 reduce, find 함수가 존재















### 재귀함수

- 순환문을 사용하여 좀 더 명확하게 구현 가능

- 재귀

```javascript
function factorial(n){
  if(n>1){
    return n * factorial(n-1);
  }else{
    return1;
  }
}
```

- 순환문

```javascript
function factorial(n){
  var result = 1;
  while(n>1){
    result = rresult * n--;
  }
  return result;
}
```















### 클로저(Closure)

- 자바스크립트의 함수는 일급 객체(first class object)
  - 함수를 인자로 전달 가능함
  - 함수를 반환할 수 있음
  - 변수에 함수를 할당 가능함

- 클로저란 함수와 함수가 선언된 어휘적 환경(Lexical scoping, environment)의 조합 [MDN 정의]
  - 리턴받는 것은 inner function의 것, 그러나 outer function의 값 또한 기억하고 있음을 의미

- 코드와 유효범위 포함(LEGB, 키워드 E)
  - 자바스크립트의 모든 함수 = 클로저
  - 함수가 클로저로 인식되는 경우는 -> 중첩함수에서 내부 함수가 외부로 전달되고 실행될 때
  - 즉 '외부로 전달되고 실행되는 함수'가 클로저의 의미

- 내부 중첩 함수

```javascript
function(argB){
  return argA + argB;
}
```

- closureFunc이 실행되고 내부 함수 temp를 반환 후 종료
  - -> 함수 종료 시 가비지 콜렉션에 의해 객체를 제거함
  - 즉 종료된 함수의 내부 변수를 참조할 수 있다는 것이 클로저의 놀라운 점















### 메소드 apply, call

- 자바스크립트의 함수는 객체이기 때문에 메소드 적용 가능

- apply, call은 함수에 전달인자를 적용하는 메소드
  - var sum = add.apply(null, [2,3]);
    - 전달인자를 적용하여 함수 실행
  - var sum = add.call(null, 2, 3);
    - 전달인자를 배열 대신 나열함
    - 전달인자가 한 개일 때 사용
  - 객체에 대해 적용하고 싶다면 -> null 대신 객체를 지정















### 커링(Curring)

- 자바스크립트의 함수가 객체, 데이터, 동적이기 때문에 커링 처리 가능
- 전달인자를 하나하나 전달하는 것을 커링이라고 함
- 즉 클로저를 이용하여 함수 내부인자 등으로 새로운 함수를 추가하는 방식
- 하나의 전달인자 코드 내 가시화 -> 하나의 전달인자 함수에 적용 -> 새로운 함수 반환 -> 두 번째 전달인자 가시화 -> 새로운 함수에 적용
- 결과는 두 개 전달인자를 동시에 적용하는 것과 동일
- 커링을 이용해 똑같은 전달 인자를 계속 입력하지 않고, 변하는 전달인자만 입력하여 코드 작성 가능

- 일반적인 함수를 커링할 수 있는 함수
  - 어떤 함수라도 커링할 수 있어야 하며, 함수의 전달인자 개수 제한이 없음
  - Dustin Diaz의 커링 함수













- 생성자 함수 - new 연산자를 통해 객체를 생성하고 프로퍼티와 메소드를 생성하여 초기화하는 자바스크립트 함수
- 프로토타입 - 생성자 함수의 프로퍼티며 생성자 함수로 생성된 객체들이 동일하게 상속받는 프로퍼티와 메소드가 정의되는 곳
- 비공개 멤버 - 객체 외부에서는 수정할 수 없는 프로퍼티 또는 메소드













### 객체

- 자바스크립트는 함수도 = 일급 객체
  - 일급 객체는 변수나 데이터 구조 안에 담을수 있음
  - 인자로 전달하거나 반환 값으로 사용
  - 동적으로 생성 가능한 객체

- 자바스크립트 객체는 class가 존재하지 않음
  - 생성자 함수, 프로토타입 객체 사용하여 객체 생성
- 객체란 이름이 지정된 프로퍼티의 모음
  - 객체 리터럴은 객체의 프로퍼티를 나열하여 객체를 생성함
- 메소드는 객체의 프로퍼티가 함수인 프로퍼티 -> 프로퍼티와 동일한 방법으로 추가 수정함
  - 객체 리터럴 방식으로 메서드 정의 가능
  - this: 자신이 속해있는 객체
- 빈 객체에 프로퍼티를 쉽게 추가할 수 있으니 빈 객체 만들어 사용
  - 빈 객체는 Namespace 구현 방법으로 사용함
    - 빈 전역객체 생성 후 사용되는 모든 변수와 객체 명을 전역객체의 Property로 생성 시 코드 내 이름 충돌 방지 가능
  - Namespace는 전역 변수 사용을 최소화하는 방법으로
    - 코드에 사용되는 변수, 함수, 객체 등을 하나의 객체 Property로 설정함
  - 전역 객체는 일반적으로 객체 이름 대문자로 명명
- 객체마다 중복되는 변하지 않는 property나 method를 prototype으로 작성하여 메모리를 절약할 수 있음
- class method를 JavaScript에 구현하기 위해서는
  - this를 사용하지 않는 method를 정의하면 됨
  - this는 new 연산자에 의해 생성자 함수로 생성된 객체를 가리킴
  - -> class method는 객체를 생성하지 않기 때문에 this를 사용 x

