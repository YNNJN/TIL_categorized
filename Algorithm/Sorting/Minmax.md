## 2020. 1. 29 TIL



### 탐욕 알고리즘 (Greedy)



- 결정을 할 때마다 그 순간에 가자 좋다고 생각되는 것을 해답으로 선택함으로써 최종적인 해답에 도달
- 그 순간의 선택은 그 당시에는 최적임. 하지만 최적이라고 생각했던 해답을 모아서 최종적인 해답을 만들었다고 해서 그 해답이 최적이라는 보장 X
- 탐욕 알고리즘은 항상 최적의 해답을 주는 지를 반드시 검증해야 함

- 일단 한 번 선택된 것은 번복하지 않음. 이렇기 때문에 단순하며, 제한적인 문제들에 적용함
- 최적해를 반드시 구한다는 보장은 없음
  - 예를들어 거스름돈 문제에서 가장 큰 돈을 먼저 선택한다는 알고리즘으로는 원하는 해를 구할 수 없음
  - 400원짜리 화폐가 있을 경우, 400원 두 번을 주는 것이 최적해







#### 동작과정



- 해 선택
  - 현재 상태에서 부분 문제의 최적해를 구한 뒤, 이를 부분 해 집합에 추가
- 실행 가능성 검사
  - 새로운 부분 해 집합이 실행 가능한 지를 확인
  - 문제 제약 조건을 위반하는지를 검사
- 해 검사
  - 새로운 부분 해 집합이 문제가 되는지를 확인
  - 아직 전체 문제의 해가 완성되지 않았으면 1의 해 선택부터 다시 시작







#### 거스름돈 문제



- 동전의 개수가 최소가 되도록 거스름돈을 줌
- 가치가 가장 큰 동전을 먼저 선택하는 것이 최소 동전 수 구하기에 최적일 것이라는 아이디어로 시작









#### baby-gin, 탐욕기법으로 풀기



- baby-gin 문제를 푸는 데 정렬을 적용하면 이점 뿐 아니라 난점도 존재, {1, 2, 3, 1, 2, 3}의 경우

- 카운트 배열에 넣고, 연속된 숫자 세 개가 카운트 배열에 나란히 있으면 하나씩 삭제하고 트리플릿으로 기록
- 한 인덱스에 세 개 이상이 있으면 셋을 삭제하고 런으로 기록
- 이 둘의 순서가 바뀌어도 상관 없음







#### 알고리즘 기초



- 맥스와 미니멈 문제 풀 때 초기화 값을 0으로 하면, 양수를 입력받을 경우 미니멈 값이 무조건 0이 됨. 이를 방지하기 위해 리스트의 처음 값으로 초기화하는 것이 필요
- 파이참 단축키

  - ctrl + D : 한줄 복사
  - shift + alt + 방향키 : 이동









#### (다른 언어에서) 삼항 연산자



조건문이 참일 때 앞의 값이 실행됨. 거짓일 때 뒤의 값이 실행됨

조건문의 괄호는 필수는 아니고 가독성 높이기 위해

```python
left = h[i-2] if (h[i-2] > h[i-1]) else h[i-1]
```









#### input 길이가 길어서 한 번에 처리하고 싶을 때



input.txt를 하나의 파일로 저장 후 해당 명령어 입력

```python
import sys

sys.stdin = open('input.txt'.'r')			#표준 입력 파일로 변경
```

-> '표준 입력을 콘솔창이 아닌 sys에서 받겠다'는 의미













- minmax

```python
t = int(input()) #test case 수 입력

for i in range(1, t+1): #t회 반복
    n = int(input()) #양수 n개 입력 받음
    posis = list(map(int, input().split())) #양수 값을 리스트로 받음
    mmax, mmin = posis[0], posis[0] #맥스와 미니멈을 양수의 첫번째 값으로 초기화

    for posi in posis: #양수 리스트 중 하나를 골라, 리스트 모두에 반복
        if mmax < posi: #맥스가 주어진 양수보다 작으면
            mmax = posi #맥스에 해당 양수를 지정
        if mmin > posi: #미니멈이 주어진 양수보다 크면
            mmin = posi #미니멈에 해당 양수를 지정

    print('#{} {}'.format(i, mmax-mmin)) #test case횟수와 맥스와 미니멈의 차이를 출력
```





- 구간합

```python
t = int(input()) #test case 수 입력

for tc in range(1, t+1): #t회 반복
    n, m = map(int, input().split()) #n개의 정수와 이웃한m의 값 입력
    a_i = list(map(int, input().split())) #정수 a_i를 입력 받음
    d = m // 2 #기준값으로부터 떨어진 정도를 구하기 위해 변수 d를 지정
    l = [] #각 구간의 합을 받기 위한 리스트 생성


    if m % 2: #m이 홀수인 경우

        for i in range(d, len(a_i)-d): #구간의 모든 값이 속할 수 있는 범위 지정
            new_a = a_i[(i-d):(i+d+1)] #리스트를 슬라이싱하여 구간별로 잘라줌
            s = sum(new_a) #각 구간에 대한 합을 구함
            l.append(s) #각 구간에 대한 합을 리스트에 더함

    else: #m이 짝수인 경우

        for i in range(d-1, len(a_i)-d): #구간의 모든 값이 속할 수 있는 범위 지정
            new_a = a_i[(i-d+1):(i+d+1)] #리스트를 슬라이싱하여 구간별로 잘라줌
            s = sum(new_a) #각 구간에 대한 합을 구함
            l.append(s) #각 구간에 대한 합을 리스트에 더함


    diff = max(l) - min(l) #최대 최소의 차를 구한 값을 변수로 지정함
    print('#{} {}'.format(tc, diff)) #테스트케이스의 회차와 최대 최소의 차를 출력함
```







- 숫자카드

```python
t = int(input()) #test case 수 입력

for tc in range(1, t+1): #test case t회 반복
    n = int(input()) #카드 장수 n 입력 받음
    nums = list(map(int, input())) #숫자를 여백 없이 리스트로 입력 받음
    l = [0 for _ in range(10)] #길이 10의 0으로 채운 리스트를 지정함


    for num in nums: #입력받은 숫자 리스트의 숫자 값에 대해 반복
        l[num] += 1 #0으로 채운 리스트에, 숫자와 동일한 인덱스에 값을 추가하여 숫자마다 카운팅 함

    max_value = 0 #가장 많은 카드의 장 수를 초기화함
    for i in l: #카운팅 리스트의 값에 대해 반복
        if max_value < i:
            max_value = i #가장 많은 카드의 장 수를 구함

    max_idx = 0 #가장 큰 인덱스, 즉 가장 많은 카드의 숫자를 초기화함
    for idx in range(len(l)): #카운팅리스트의 인덱스에 대해 반복
        if l[idx] == max_value: #카운트 한 값이 가장 많은 카드의 장 수와 같을 때
            if max_idx < idx:
                max_idx = idx #가장 큰 인덱스를 구함, 이것이 곧 가장 많은 카드의 숫자를 의미함

    print('#{} {} {}'.format(tc, max_idx, max_value)) #테스트 케이스, 가장 많은 카드의 숫자, 장 수를 차례로 출력함
```

