## 2020. 1. 28 TIL



#### 프로그램

- 컴퓨터가 특정 작업을 수행하기 위해 짜여진 명령의 순서
- 원하는 작업의 일 순서 및 명세를 빠짐없이 알려줘야

- 컴퓨터가 이해할 수 있는 언어로
  - 기계어 -> 어셈블리어 -> 씨 -> 자바 -> 파이썬(언어에 가까운 언어)





#### 프로그래밍

- 하나 이상의 관련 추상 알고리즘을 특정 프로그래밍 언어를 이용해 구체적 프로그램으로 구현하는 기술
- 산출물은 코드 / 소스





#### 알고리즘 

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
- 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
- 어떠한 문제를 해결하기 위한 절차
- 문제 해결력을 기르기 위한 수단





#### 문제 해결의 중요 요소

- 문제 해결 과정을 단계별(알고리즘은 절차적인 것이니)로 나누는 것
- 문제를 올비로 이해하는 것





#### 프로그래밍을 통한 문제 해결

- 문제를 읽고 이해함
- 문제를 익숙한 용어로 재정의함 (입력과 출력의 형태로 정의)
- 어떻게 해결할지 계획을 세움 (ex. '모든' -> 조합)
- 계획을 검증함 (test set 이용)
- 프로그램으로 구현함
- 어떻게 풀었는지 돌아보고 개선할 방법이 있는지 찾아봄





#### 문제 해결 전략

- 이전에 경험한 비슷한 문제 응용하기
- 단순하게 시작하기
  - 가장 단순한 알고리즘으로 시작 -> 나중에 최적화
  - 우선 완전 검색으로 접근하여 해답을 도출 -> 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직
  - 처음부터 nice하게 풀려는 강박 X
- 문제를 단순화하기
  - 계산해야 하는 변수를 줄이거나 다차원을 저차원으로 표현
  - 이중 루프 -> for문 분리: 10*10 -> 10+10
- 그림으로 표현하기 (ex. 표, 순서도, 슈더코드)
- 뒤에서부터 문제 풀기





#### 알고리즘의 일반적 특성

- 정확성
  - 알고리즘은 주어진 입력에 대해 올바른 해를 주어야 함
  - 끝부분 처리, if 문 처리,,,, 에서 정확하지 못했던 것이 숨겨진 케이스에서 들킴
- 수행성
  - 알고리즘의 각 단계는 컴퓨터에서 수행 가능하여야 함
  - 프로그래밍 언어에 대한 이해 ⬆
- 유한성
  - 알고리즘은 유한 시간 내에 종료되어야 함
  - 조금 더 빠른, 새로운 알고리즘의 적용을 고민해야
- 효율성
  - 알고리즘은 효율적일수록 그 가치가 높아짐





#### 컴퓨터 분야에서 알고리즘을 표현하는 방법

1. 슈더코드
   - 주요한 내용만 기술
   - 파이썬은 슈더코드와 거의 비슷한 언어

2. 순서도
   - for문도 조건임을 인지 (for in range(1, n+1) -> 	i <= 100)
   - 순서도에서 선이 다시 돌아옴 -> 반복문





#### 최대값 찾기

- 자연어로 알고리즘 표현

- 슈도코드로 표현

  ```
  1. max = A[10]
  2. for i = 1 to 9					#배열이니까
  3. if (A[i] > max) max = A[i]
  4. max 출력
  ```

- 순서도로 표현





#### 알고리즘의 수행 시간 분석

- 수행 시간을 공정하게 평가하기 위해서는 조건이 동일한 기계에서 측정한 수행 시간을 측정해야 하는데, 이는 현실적으로 불가능
- 수행 연산 횟수를 비교하는 방식으로 성능을 분석해야 함





#### 알고리즘의 성능 -> 시간 복잡도로 표현(most popular)

- 실행되는 명령문의 수를 계산 -> n의 함수로 표현
- 즉 기본적인 연산의 수를 입력의 크기(n)에 대한 함수로 표현
  - 기본적 연산: 더 작게 쪼갤 수 없는 최소 크기의 연산
  - ex. 사칙 연산/ 대입/ 실수 대소 비교 등
- 시간 복잡도가 크면 입력의 크기가 증가할 때 수행 시간이 더 빠르게 증가함





#### 수행 시간 

- 반복문 이중 루프 n * n = n^2
- 반복문 따로 수행 n + n = 2n





#### Big-O Notation

- 주어진 함수에서 가장 빨리 증가하는 항만 고려
  - like 반응속도 식 반응 차수 구하기
- 즉 가장 큰 영향력을 주는 항만 선택함
- 계수는 생략하여 표시
- O(1) < O(log n ) < O(n) < O(n log n) < O(n^2) < O(2^n) < O(n!)





#### 배열

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료 구조
- 6개의 변수를 사용하는 경우 -> 배열로 바꾸어 사용
- 배열 Num에서 Num[i], i는 변경할 수 있는 숫자. index라고 함
  - index는 문자가 아니라 숫자이므로 반복 가능 (iterable)
- 변수 Num은 조작 불가









#### 예제 1. while, continue, break 복습

```python
i = 0
while True:
    if i % 10 != 3:
        i += 1
        continue
        
    if i > 73:
        break

    print(i, end=' ')
    i += 1
```





#### 1차원 배열 입력 받기

```python
arr = list(map(int, input().split()))
print(arr)
```



#### 2차원 배열 입력 받기

```python
#2차원 배열 입력 받기
# 3행
# 123
# 456
# 789

N = int(input())
arr1 = [0 for _ in range(N)]     
arr2 = [list(map(int, input().split())) for _ in range(N)]
print(arr1)
print(arr2)
```



#### N번만큼 앞의 내용을 반복

```python
for _ in range(N)		# _ : 반복계수가 필요 없음을 의미. 0을 N번 반복하여 리스트에 넣음
```



#### 0을 M만큼 리스트에 담은 것을 N번 반복

```python
room = [[0 for _ in range(M)] for _ in range(N)]]
```



[python 2d array indexing](https://www.tutorialspoint.com/python_data_structure/python_2darray.htm)









#### Gravity



```python
#낙차가 가장 큰 상자를 리턴

'''
1
9 8
7 4 2 0 0 6 0 7 0
'''

t = int(input())

for test_case in range(1, t+1):
    N, M = map(int, input().split())
    boxTop = list(map(int, input().split()))
    room = [[0 for _ in range(M)] for _ in range(N)]

    for i in range(N):                  #각 행을 반복하면서
        for j in range(boxTop[i]):      #박스 최대 높이만큼만
            room[i][j] = 1              #박스 높이만큼 1로 채우기

    for row in room:
        print(row)

    max = 0
    for i in range(N):
        if boxTop[i] > 0:
            cnt = 0                     #낙차 수 세기
            for j in range(i+1, N):
                if room[j][boxTop[i]-1] == 0:
                    cnt += 1
            if max < cnt:
                max = cnt

    print(max)
```



1. 각 행렬을 박스탑의 유무에 따라 0과 1로 채움

2. for row in room (일렬이 아닌 가로로 쌓음)

3. max <- 최대 낙차 저장

4. 행마다 순회하면서

5. 상자가 있다면

6. 상자 위치 한 칸 다음(낙차니까, for문을 돌 범위가 상자의 위치마다 변경됨)부터
   마지막까지 갯수를 세어나가기 (단, 빈칸(0)일 경우만) -> cnt에 저장

7. 그 갯수 중 최대값을 찾아내기







#### Baby_gin Game



#### 완전 검색 (Exaustive search)

- 모든 경우의 수를 나열해보고 확인하는 기법
- 모든 경우의 수를 테스트한 후 최종 해법 도출
- Brute-Force
- Generate-and-test
- 수행 속도는 느리지만 해답을 찾지 못할 확률 낮음
  - 선택해야하는 숫자가 늘어나면 시간복잡도가 급격히 커짐
  - 카드 세 장 -> 6, 네 장 -> 24, 다섯 장 -> 120, 여섯 장 -> 720
- 일반적으로 경우의 수가 상대적으로 작을 때 유용



#### 순열 (permutation)

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개의 원소에서 r개를 중복 없이 골라서 순서에 상관 있게 나열하는 것
- 파이썬은 순열을 생성하는 코드 내장
- 하지만 짤 줄도 알아야 해

```python
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i1 != i2:
            for i3 in range(1, 4):
                if i3 != i2 and i3 != i1:
                    print(i1, i2, i3)
```

- 첫 번째 선택 요소 - 두 번째 - 세 번째 
  - for문을 세 번 돌리되, 쓸모없는 것(중복해서 세어지는 것) 조건문으로 제외함
- 마찬가지로, baby-gin 문제를 6장의 카드에 대해 실행하려면 6중 for문이 필요







#### 정렬

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값 혹은 그 반대의 순서대로 재배열하는 것
  - 정렬이 되어있을 때와 되어있지 않을 때 자료의 찾을 수 있는 시간이 현격하게 차이남
  - 수행 시간을 줄이는 것이 목표이기 때문에, 정렬을 알아야



#### 버블 정렬

- 데이터 집합 내의 이웃 요소들끼리의 교환을 통해 정렬
  - 인접한 두 개의 원소를 비교하여 자리를 계속 교환하는 방식
    - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막자리까지 이동
    - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨
- 찾아내고 싶은 숫자가 교환을 통해 자리를 이동하며 둥둥둥 위로 떠오르는 것이 버블 같아 버블 정렬이라 이름 붙여짐



- 버블 정렬 함수 구현해서, arr 배열을 오름차순으로 정렬하세요

```python
def bubble_sort(arr):
    for i in range(len(arr)-1, 0, -1):
        for j in range(i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

arr = [3, 4, 2, 1, 5]
bubble_sort(arr)
print(arr)
```







#### 카운팅 정렬

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개 씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    - 각 항목의 발생 횟수를 기록하기 위해 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함



1. 주어진 배열을 정렬함

2. 가장 큰 정수만큼 인덱스를 이용할 배열을 만듦

3. 각 인덱스 내지 수의 빈도를 각 자리에 저장함

4. 1번 인덱스부터 자기 앞의 숫자를 자기와 더함



- 몇 번째 자리까지 내 숫자를 채우면 되겠구나, 에서 비롯한 아이디어
- 위치~빈도의 관계를 만들어준거군
- 정렬할 배열의 숫자 범위에 관계 없이 순회할 횟수가 중복을 제외한 숫자만큼으로 일정





- 카운팅 정렬 함수 구현해서, arr 배열을 오름차순으로 정렬하세요

```python
def counting_sort(A, B, k): #A는 정렬한 배열, k는 배열의 최대값 의미
    C = [0] * k

    for i in range(len(A)): #A배열의 원소의 갯수를 세서 카운트 배열에 넣음
        C[A[i]] += 1

    for i in range(1, len(C)): #카운트 배열 조작하기: 숫자들이 들어갈 자리를 표현하도록 내 앞 인덱스 숫자를 더해서 대입함
        C[i] += C[i-1]

    for i in range(len(A)-1, 0, -1): #정렬하기
        C[A[i]] -= 1 #내 자리 것을 가져와서 한 칸 뺌
        B[C[A[i]]] = A[i]
    return B



arr = [0, 4, 1, 3, 1, 2, 4, 1]
print(counting_sort(arr, [0]*len(arr), 5))
```











디버거 사용법

- 프로그램이 돌아가는 중간에 내가 참견해보는 것(중간에서 print하는 것과 같은 방법)
- 원하는 곳에 중단점 설정 -> 우클릭 또는 상단 창의 debugging mode 실행
- 반복문에서 i와 j가 변하는 모습 살필 수 있음. 즉 변수 안의 변화를 추적할 수 있음
  - 버블 솔트에서는 i가 점점 줄어드는 단계가 보임
  - 오른쪽 삼각형 모양 눌러서 한 텀 다음을 볼 수 있음

